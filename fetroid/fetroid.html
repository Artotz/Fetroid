<!doctype html>
<html>
<head>
  <title> Fetroid </title>
  <meta charset="utf-8"></meta>
  <link rel="stylesheet" type="text/css" href="scripts/canvas.css"></link>
  <script type="text/javascript" src="scripts/logicalFunctions.js"></script>
  <script type="text/javascript" src="scripts/monsters.js"></script>
</head>
<body bgcolor = "#36F" oncontextmenu = "return false">
<script>


//-------------------- VARIÁVEIS -------------------------------------------------------------------------------
  var
    // VARIAVEIS CONFUSAS ------------------
    auxG = 0, //  Serve pra contar regressivamente o floatTime definido. Importante pra float time
    airFramesGlobal = 0, // Remover quando terminar de debuggar

    // CANVAS & FRAMES ---------------------
    canvas,
    ctx,
    frames = 0,

    // PLAYER 1 ----------------------------
          // Possui Struct, botões e controles.
          // Importante: "x" & "y" não são coordenadas da ponta superior esquerda, mas sim do centro da hitbox.
          // Para pegar coordenadas da ponta superior esquerda, deve-se fazer "x - p1.width"

    p1 = {x: 100, y: 100, width: 50, height: 50, dx: 0, dy: 0, accX: 0, accY: 0, onGround: false},
    p1Keys = {u: 87, l: 65, d: 83, r: 68},
    p1Control = {u: false, l: false, d: false, r: false};

    aux = [false, false, false, false, false, false, false, false],

    // MONSTROS --------------------------------
    mobList = [];

    function fillMobList(){
        mobList  = [];
        //  IDENTIFICA O QUE FOR MONSTRO NA GRID
        for(let i = 0; i < grid.length; i++){
            for(let j = 0; j < grid[0].length; j++){
                if (grid[i][j] >= 20){
                  mobList.push(new mob(i, j, grid[i][j]));
                }

            }
        }

        //  ESPECIFICA OS MONSTROS DE CADA ELEMENTO
        for (var i = 0; i < mobList.length; i++){
            switch (mobList[i].gridNumber){
              case 21:
                mobList[i] = new mob1(mobList[i].spawnI,mobList[i].spawnJ,mobList[i].gridNumber);
                break;
              case 22:
                //mobList[i] = new mob2(mobList[i].spawnI,mobList[i].spawnJ,mobList[i].gridNumber);
                break;

              default:

            }

        }

    }

    function updateMobList(){

    }

    function drawMobList(){

    }
var
    // MAPAS --------------------------------
    tile = 70, // Tamanho do tile/quadrado da grade

  grid =     [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
              [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
              [1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1],
              [1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,1],
              [1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1],
              [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],

  gridDraw = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
              [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
              [1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1],
              [1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1],
              [1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1],
              [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],


    // CAMPO DE VISÃO --------------------------
    zoom = 1,    //  Define o quão maior as imagens vão ser desenhadas no canvas
    offset = {x: 0, y: 0},  // Descolamento da câmera, começando do começo do mapa, para acompanhahr o movimento do jogador.(0,0) indica que está no começo do mapa.
                            // Offset pode ser entendido como os valores de deslocamento da câmera para acompanhar o personagem.
                            // Os valores indicam o quanto mais para frente/trás as coisas serão desenhadas

    width = tile * 13, // Comprimento, em pixels, do campo de visão do jogador
    height = tile * 9, // Altura, em pixels, do campo de visão do jogador


    gI = grid.length,      // Comprimento, em blocos, do mapa todo
    gJ = grid[0].length,   // Altura, em blocos, do mapa todo
    mapWidth = gJ * tile,  // Comprimento, em pixels, do mapa todo
    mapHeight = gI * tile; // Altura, em pixels, do mapa todo


// ---------------- UPDATE -------------------------------------------------------------------------------


  // COLISÕES --------------------------
  function checkCollision(Player){

  }

  function controlPlayer(Player, Control){
    var accX, maxAccX, maxVelX, grav, floatGrav, maxAccY, jmpVel, maxVelY, floatTime, airFrames;

    // HORIZONTAL
    accX = 0.2; //accX por frame
    maxAccX = 2;
    maxVelX = 7.4;

    if(Control.l){ // Se control.left estiver pressionado
      if(p1.onGround == false)  // Modifica a velocidade do player1 no ar
        maxVelX = 5.5;
      else {
        maxVelX = 7;
      }
      if(Player.accX > 0) // Modifica velocidade do player1 em turning
        Player.accX = 0;
      Player.accX -= accX;
      if(Player.accX < -maxAccX)
        Player.accX = -maxAccX;
    }
    else if(Control.r){// Se control.right estiver pressionado
      if(p1.onGround == false)  // Modifica a velocidade do player1 no ar
        maxVelX = 5.3;
      else {
        maxVelX = 7;
      }
      if(Player.accX < 0) // Modifica velocidade do player1 em turning
        Player.accX = 0;
      Player.accX += accX;
      if(Player.accX > maxAccX)
        Player.accX = maxAccX;
    }
    else
      Player.accX = 0;

    // Definição de velocidade
    Player.dx += Player.accX;
    if(Player.dx > maxVelX)
      Player.dx = maxVelX;
    if(Player.dx < -maxVelX)
      Player.dx = -maxVelX;

    // Atrito
    if(Player.accX == 0)
      Player.dx = 0;
    //if(Math.abs(Player.dx) < 0.01)
    //  Player.dx = 0;

    // VERTICAL
          // Curiosidades com os dados atuais: você fica 6 frames em estado Coiote
          // Shorthop: 27 frames
          // Normal Jump: 45 frames
          // Coiote Jump: 48 frames

    airFrames = 0; // Quantidade de frames do player no ar
    grav = 0.2; //gravidade AKA Aceleração da aceleração
    floatGrav = 0.13; //gravidade quando UP esta pressionado AKA Aceleração da aceleração quando UP está pressionado
    floatTime = 25; //por quanto tempo floatGrav dura (frames)
    maxAccY = 0.6; //acc y max AKA Aceleração de verdade
    jmpVel = -12.5; //velocidade do pulo
    maxVelY = 15.5; //velocidade max

    if(Control.u){
      if(Player.onGround){
        airFrames = 0;
        airFramesGlobal= 0; // Remover quando terminar de debuggar
        Player.dy = jmpVel;
        Player.onGround = false;
        auxG = floatTime;
      } else if(auxG > 0){
        auxG--;
      }
    }
    else
      auxG = 0;

    if(!Player.onGround){
      airFrames++;
      airFramesGlobal++; // Remover quando terminar de debuggar
      if (Player.dy < 0 && airFrames <= 10 && !Control.u){
          if (airFramesGlobal == 10)
            Player.dy = 0;
      }
      /* // Aqui é caso tu quisesse usar um tamanho de pulo (medido em airframes) maior que o limite de airframes pra castar o shorthop
        // PS: ainda teria que declarar "shorthop" e colocar um "shorthop = true;" no 'if' anterior
      if (airFramesGlobal == 10 && shorthop == true){
        Player.dy = 0;
        shorthop = false;
      }*/

      if(auxG == 0)
        Player.accY += grav;
      else{
        Player.accY += floatGrav;
        if(Player.dy >= 0){
          Player.accY = 0;
          Player.dy = 0;
        }
      }

      if(Player.accY > maxAccY)
        Player.accY = maxAccY;
    }

    var bI, bJ;
    bI = Math.floor(Player.y / tile);
    bJ = Math.floor(Player.x / tile);

    bJE = Math.floor((Player.x -Player.width/2) / tile);
    bJD = Math.floor((Player.x +Player.width/2) / tile);
    if(!(Player.y + Player.height/2 + 1 > mapHeight ||
        (Player.y + Player.height/2 == (bI+1) * tile && grid[bI+1][bJE] == 1) ||
        (Player.y + Player.height/2 == (bI+1) * tile && grid[bI+1][bJD] == 1)))
      Player.onGround = false;

    Player.dy += Player.accY;
    if(Player.dy > maxVelY)
      Player.dy = maxVelY;

    ////////////////////////////////////////////////////////////////////
    ///COLISION
    ////////////////////////////////////////////////////////////////////

    //VARIAVEIS

    var fPlayer;
    var collidedX, collidedY;
    collidedX = collidedY = false;
    aux = [false, false, false, false, false, false, false, false];

    // var px1, px2, px3, px4;
    // px1 = {x: (bJ) * tile, y: (bI) * tile};
    // px2 = {x: (bJ+1) * tile, y: (bI) * tile};
    // px3 = {x: (bJ+1) * tile, y: (bI+1) * tile};
    // px4 = {x: (bJ) * tile, y: (bI+1) * tile};
    //
    // var disX, disY;
    // var aaa = true;
    //
    // if(Player.dx < 0){
    //     if(Player.dy < 0){
    //       disX = Math.abs((Player.x -Player.width/2) - px1.x);
    //       disY = Math.abs((Player.y -Player.height/2) - px1.y);
    //     }
    //     else if(Player.dy > 0){
    //       disX = Math.abs((Player.x -Player.width/2) - px4.x);
    //       disY = Math.abs((Player.y +Player.height/2) - px4.y);
    //     }
    // }
    // else if(Player.dx > 0){
    //     if(Player.dy < 0){
    //       disX = Math.abs((Player.x +Player.width/2) - px2.x);
    //       disY = Math.abs((Player.y -Player.height/2) - px2.y);
    //     }
    //     else if(Player.dy > 0){
    //       disX = Math.abs((Player.x +Player.width/2) - px3.x);
    //       disY = Math.abs((Player.y +Player.height/2) - px3.y);
    //     }
    // }
    //
    // if(disX < disY)
    //   aaa = false;

    //TRATAMENTO

    //VERTICAL------------------------------------------------------------------

    fPlayer = {x: Player.x + Player.dx -Player.width/2,
       y: Player.y + Player.dy -Player.height/2,
       width: Player.width, height: Player.height};

    //BAIXO
    if(Player.dy >= 0){
      if(rectCollision(fPlayer, {x: (bJ-1) * tile, y: (bI+1) * tile, width: tile, height: tile})
      && grid[bI+1][bJ-1] == 1 && grid[bI][bJ-1] == 0){
        Player.dy = 0;
        Player.y = (bI+1) * tile - Player.height/2;
        Player.dy = 0;
        Player.accY = 0;
        Player.onGround = true;
        aux[6] = true;
      }
      if(rectCollision(fPlayer, {x: (bJ) * tile, y: (bI+1) * tile, width: tile, height: tile})
      && grid[bI+1][bJ] == 1){
        Player.dy = 0;
        Player.y = (bI+1) * tile - Player.height/2;
        Player.dy = 0;
        Player.accY = 0;
        Player.onGround = true;
        aux[6] = true;
      }
      if(rectCollision(fPlayer, {x: (bJ+1) * tile, y: (bI+1) * tile, width: tile, height: tile})
      && grid[bI+1][bJ+1] == 1 && grid[bI][bJ+1] == 0){
        Player.dy = 0;
        Player.y = (bI+1) * tile - Player.height/2;
        Player.dy = 0;
        Player.accY = 0;
        Player.onGround = true;
        aux[6] = true;
      }
    }

    //CIMA
    else if(Player.dy < 0){
          if(rectCollision(fPlayer, {x: (bJ-1) * tile, y: (bI-1) * tile, width: tile, height: tile})
          && grid[bI-1][bJ-1] == 1 && grid[bI][bJ-1] == 0){
           Player.dy = 0;
           Player.y = (bI) * tile + Player.height/2;
           auxG = 0;
           aux[1] = true;
          }
          if(rectCollision(fPlayer, {x: (bJ) * tile, y: (bI-1) * tile, width: tile, height: tile})
          && grid[bI-1][bJ] == 1){
           Player.dy = 0;
           Player.y = (bI) * tile + Player.height/2;
           auxG = 0;
           aux[1] = true;
          }
          if(rectCollision(fPlayer, {x: (bJ+1) * tile, y: (bI-1) * tile, width: tile, height: tile})
          && grid[bI-1][bJ+1] == 1 && grid[bI][bJ+1] == 0){
           Player.dy = 0;
           Player.y = (bI) * tile + Player.height/2;
           auxG = 0;
           aux[1] = true;
          }
        }

    //HORIZONTAL----------------------------------------------------------------

    fPlayer = {x: Player.x + Player.dx -Player.width/2,
      y: Player.y + Player.dy -Player.height/2,
       width: Player.width, height: Player.height};

    //DIREITA
    if(Player.dx > 0){
      if(rectCollision(fPlayer, {x: (bJ+1) * tile, y: (bI-1) * tile, width: tile, height: tile})
      && grid[bI-1][bJ+1] == 1 && grid[bI-1][bJ] == 0){
        Player.dx = 0;
        Player.x = (bJ+1) * tile - Player.width/2;
      }
      if(rectCollision(fPlayer, {x: (bJ+1) * tile, y: (bI) * tile, width: tile, height: tile})
      && grid[bI][bJ+1] == 1){
        Player.dx = 0;
        Player.x = (bJ+1) * tile - Player.width/2;
      }
      if(rectCollision(fPlayer, {x: (bJ+1) * tile, y: (bI+1) * tile, width: tile, height: tile})
      && grid[bI+1][bJ+1] == 1 && grid[bI+1][bJ] == 0){
        Player.dx = 0;
        Player.x = (bJ+1) * tile - Player.width/2;
      }
    }

    //ESQUERDA
    else if(Player.dx < 0){
      if(rectCollision(fPlayer, {x: (bJ-1) * tile, y: (bI-1) * tile, width: tile, height: tile})
      && grid[bI-1][bJ-1] == 1 && grid[bI-1][bJ] == 0){
        Player.dx = 0;
        Player.x = (bJ) * tile + Player.width/2;
      }
      if(rectCollision(fPlayer, {x: (bJ-1) * tile, y: (bI) * tile, width: tile, height: tile})
      && grid[bI][bJ-1] == 1){
        Player.dx = 0;
        Player.x = (bJ) * tile + Player.width/2;
      }
      if(rectCollision(fPlayer, {x: (bJ-1) * tile, y: (bI+1) * tile, width: tile, height: tile})
      && grid[bI+1][bJ-1] == 1 && grid[bI+1][bJ] == 0){
        Player.dx = 0;
        Player.x = (bJ) * tile + Player.width/2;
      }
    }

    //AAA-----------------------------------------------------------------------

    Player.x += Player.dx;
    Player.y += Player.dy;

  }

  function boundPlayer(Player){
    if(Player.x + Player.width/2 > mapWidth){
      Player.x = mapWidth - Player.width/2;
      Player.dx = 0;
      Player.accX = 0;
    }
    else if(Player.x - Player.width/2 < 0){
      Player.x = Player.width/2;
      Player.dx = 0;
      Player.accX = 0;
    }

    if(Player.y + Player.height/2 > mapHeight){
      Player.y = mapHeight - Player.height/2;
      Player.dy = 0;
      Player.accY = 0;
      Player.onGround = true;
    }
    else if(Player.y - Player.height/2 < 0){
      Player.y = Player.height/2;
      Player.dy = 0;
    }
  }

// ---------------- DRAW ---------------------------------------------------------------------------------

  function drawPlayer(Player){
    ctx.fillRect(Player.x -Player.width/2 -offset.x, Player.y -Player.height/2 -offset.y, Player.width, Player.height);

    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(Player.x -offset.x +5*Player.accX, Player.y -offset.y, 5, 0, 2*Math.PI, false);
    ctx.fill();
  }

  function drawGrid(){
    ctx.globalAlpha = 1/5;
    ctx.lineWidth = 2;
    for(var i = 0; i < gI+1; ++i){
      ctx.beginPath();
      ctx.moveTo(0 -offset.x, i*tile -offset.y);
      ctx.lineTo(mapWidth -offset.x, i*tile -offset.y);
      ctx.stroke();
    }

    for(var j = 0; j < gJ+1; ++j){
      ctx.beginPath();
      ctx.moveTo(j*tile -offset.x, 0 -offset.y);
      ctx.lineTo(j*tile -offset.x, mapHeight -offset.y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgb(30, 30, 200)';
    for(var i = 0; i < gI; i++){
      for(var j = 0; j < gJ; j++){
        if(grid[i][j] == 1){
          ctx.fillRect(j * tile -offset.x, i * tile -offset.y, tile, tile);
        }

      }
    }

  }

// ----------- MANIPULAÇÃO DE TECLAS ----------------------------------------------------------------------

  function keyDown(evt){
    console.log(evt.keyCode);
    switch(evt.keyCode){
      case p1Keys.u:
        p1Control.u = true;
        break;
      case p1Keys.l:
        p1Control.l = true;
        break;
      case p1Keys.d:
        p1Control.d = true;
        break;
      case p1Keys.r:
        p1Control.r = true;
        break;
    }
  }

  function keyUp(evt){
    switch(evt.keyCode){
      case p1Keys.u:
        p1Control.u = false;
        break;
      case p1Keys.l:
        p1Control.l = false;
        break;
      case p1Keys.d:
        p1Control.d = false;
        break;
      case p1Keys.r:
        p1Control.r = false;
        break;
    }
  }

  function mDown(evt){
  }

  function mUp(evt){
  }

  function mMove(evt){
  }

// ---------------- O JOGO -------------------------------------------------------------------------------

  function main(){
    canvas = document.createElement("canvas");

    canvas.width = width;
    canvas.height = height;

    ctx = canvas.getContext("2d");

    window.addEventListener("keydown", keyDown, false);
    window.addEventListener("keyup", keyUp, false);

    ctx.font = "20px Arial";

    document.body.appendChild(canvas);

    // vai sair daqui em breve
    fillMobList();


    run();
  }

  function run(){
    update();
    render();
    window.requestAnimationFrame(run);
  }

  function update(){
    controlPlayer(p1, p1Control);
    boundPlayer(p1);

  	//ZOOM
    //zoom = 1;

  	offset.x = (-(1/zoom)*width/2 + p1.x -p1.width/2);
  	offset.y = (-(1/zoom)*height/2 + p1.y -p1.height/2);

    if(offset.x < 0) offset.x = 0;
    else if(offset.x > mapWidth -width) offset.x = mapWidth -width;

    if(offset.y < 0) offset.y = 0;
    else if(offset.y > mapHeight -height) offset.y = mapHeight -height;

    for(var i = 0; i < mobList.length; i++)
      mobList[i].update();

  }

  function render(){
    //Tela Branca
    ctx.fillStyle = "#FFF";
    ctx.fillRect(0, 0, width, height);

    //Salva as configuraçoes atuais do context
    ctx.save();

    //Redimensiona o canvas em X e Y de acordo com esses fatores
    //(se o context nao fosse salvo, o scale iria mudar de forma
    //progressiva (0.5 * 0.5 = 0.25))
    ctx.scale(zoom, zoom);

    //Desenha o player
    ctx.fillStyle = "#F00";
    drawPlayer(p1);

    //Desenha a grid
    ctx.fillStyle = "#000";
    drawGrid();

    for(var i = 0; i < mobList.length; i++)
      mobList[i].draw();


    ////////////////////////
    //DEBUGGING
    //////////////////////////

    ctx.fillStyle = "#F00";

    //I e J do Player
    var bI, bJ;
    bI = Math.floor(p1.y / tile);
    bJ = Math.floor(p1.x / tile);

    var px1, px2, px3, px4;
    px1 = {x: (bJ) * tile, y: (bI) * tile};
    px2 = {x: (bJ+1) * tile, y: (bI) * tile};
    px3 = {x: (bJ+1) * tile, y: (bI+1) * tile};
    px4 = {x: (bJ) * tile, y: (bI+1) * tile};

    ctx.fillStyle = "#F00";
    ctx.beginPath();
    ctx.arc(px1.x -offset.x, px1.y -offset.y, 5, 0, 2*Math.PI, false);
    ctx.fill();

    ctx.fillStyle = "#0F0";
    ctx.beginPath();
    ctx.arc(px2.x -offset.x, px2.y -offset.y, 5, 0, 2*Math.PI, false);
    ctx.fill();

    ctx.fillStyle = "#00F";
    ctx.beginPath();
    ctx.arc(px3.x -offset.x, px3.y -offset.y, 5, 0, 2*Math.PI, false);
    ctx.fill();

    ctx.fillStyle = "#FF0";
    ctx.beginPath();
    ctx.arc(px4.x -offset.x, px4.y -offset.y, 5, 0, 2*Math.PI, false);
    ctx.fill();

    //TILES DE COLISAO
    //[0][1][2]
    //[3][X][4]
    //[5][6][7]

    // if(aux[0])
    //   ctx.fillRect((bJ-1) * tile -offset.x, (bI-1) * tile -offset.y, tile, tile);
    // if(aux[1])
    //   ctx.fillRect((bJ) * tile -offset.x, (bI-1) * tile -offset.y, tile, tile);
    // if(aux[2])
    //   ctx.fillRect((bJ+1) * tile -offset.x, (bI-1) * tile -offset.y, tile, tile);
    // if(aux[3])
    //   ctx.fillRect((bJ-1) * tile -offset.x, (bI) * tile -offset.y, tile, tile);
    // if(aux[4])
    //   ctx.fillRect((bJ+1) * tile -offset.x, (bI) * tile -offset.y, tile, tile);
    // if(aux[5])
    //   ctx.fillRect((bJ-1) * tile -offset.x, (bI+1) * tile -offset.y, tile, tile);
    // if(aux[6])
    //   ctx.fillRect((bJ) * tile -offset.x, (bI+1) * tile -offset.y, tile, tile);
    // if(aux[7])
    //   ctx.fillRect((bJ+1) * tile -offset.x, (bI+1) * tile -offset.y, tile, tile);

    //volta para as configuraçoes salvas
    ctx.restore();


    ctx.fillStyle = "#F00";
    //X E Y DO PLAYER
    ctx.fillText("X: " + p1.x.toFixed(2) + " Y: " + p1.y.toFixed(2), 25, 25);

    //DX E DY DO PLAYER
    ctx.fillText("dX: " + p1.dx.toFixed(2) + " dY: " + p1.dy.toFixed(2), 25, 45);

    //ACCX E ACCY DO PLAYER
    ctx.fillText("accX: " + p1.accX.toFixed(2) + " accY: " + p1.accY.toFixed(2), 25, 65);

    //I E J DO PLAYER
    ctx.fillText("I: " + bI + " J: " + bJ, 25, 85);

    //SE O PLAYER ESTA NO CHAO OU NAO
    ctx.fillText("gnd: " + p1.onGround, 25, 105);

    //OFFSET X E OFFSET Y
    ctx.fillText("offX: " + offset.x.toFixed(2) + " offY: " + offset.y.toFixed(2), 25, 125);

    //COIOTE TIME
    ctx.fillText("Aux: " + auxG, 25, 145);

    //FRAMES NO AR
    ctx.fillText("Air Frames " + airFramesGlobal, 25, 165);
  }

  main();

</script>
</body>
</html>
