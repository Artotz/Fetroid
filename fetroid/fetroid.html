<!doctype html>
<html>
<head>
  <title> Fetroid </title>
  <meta charset="utf-8"></meta>
  <link rel="stylesheet" type="text/css" href="scripts/canvas.css"></link>
  <script type="text/javascript" src="scripts/logicalFunctions.js"></script>
</head>
<body bgcolor = "#36F" oncontextmenu = "return false">
<script>


//-------------------- VARIÁVEIS -------------------------------------------------------------------------------

  var
    // VARIAVEIS CONFUSAS ------------------
    auxG = 0, //  Variavel global fudida. Serve pra contar regressivamente o floatTime definido. Importante pra float time

    // CANVAS & FRAMES ---------------------
    canvas,
    ctx,
    frames = 0,

    // PLAYER 1 ----------------------------
          // Possui Struct, botões e controles.
          // Importante: "x" & "y" não são coordenadas da ponta superior esquerda, mas sim do centro da hitbox.
          // Para pegar coordenadas da ponta superior esquerda, deve-se fazer "x - p1.width"

    p1 = {x: 100, y: 100, width: 50, height: 50, dx: 0, dy: 0, accX: 0, accY: 0, onGround: false},
    p1Keys = {u: 87, l: 65, d: 83, r: 68},
    p1Control = {u: false, l: false, d: false, r: false};

    aux = [false, false, false, false, false, false, false, false],

    // MAPAS --------------------------------
    tamBloco = 70, // Tamanho do tile/quadrado da grade

    grid = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],


    // CAMPO DE VISÃO --------------------------
    zoom = 1,    //  Define o quão maior as imagens vão ser desenhadas no canvas
    offset = {x: 0, y: 0},  // Descolamento da câmera, começando do começo do mapa, para acompanhahr o movimento do jogador.(0,0) indica que está no começo do mapa.
                            // Offset pode ser entendido como os valores de deslocamento da câmera para acompanhar o personagem.
                            // Os valores indicam o quanto mais para frente/trás as coisas serão desenhadas

    width = tamBloco * 13, // Comprimento, em pixels, do campo de visão do jogador
    height = tamBloco * 9, // Altura, em pixels, do campo de visão do jogador


    gI = grid.length,      // Comprimento, em blocos, do mapa todo
    gJ = grid[0].length,   // Altura, em blocos, do mapa todo
    mapWidth = gJ * tamBloco,  // Comprimento, em pixels, do mapa todo
    mapHeight = gI * tamBloco; // Altura, em pixels, do mapa todo


// ---------------- UPDATE -------------------------------------------------------------------------------

  // COLISÕES --------------------------
  function checkCollision(Player){

  }

  function controlPlayer(Player, Control){
    var accX, maxAccX, maxVelX, grav, floatGrav, maxAccY, jmpVel, maxVelY, floatTime;

    // HORIZONTAL
    accX = 0.2; //accX por frame
    maxAccX = 2;
    maxVelX = 7;

    if(Control.l){ // Se control.left estiver pressionado
      if(Player.accX > 0) //
        Player.accX = 0;
      Player.accX -= accX;
      if(Player.accX < -maxAccX)
        Player.accX = -maxAccX;
    }
    else if(Control.r){// Se control.right estiver pressionado
      if(Player.accX < 0)
        Player.accX = 0;
      Player.accX += accX;
      if(Player.accX > maxAccX)
        Player.accX = maxAccX;
    }
    else
      Player.accX = 0;

    // Definição de velocidade
    Player.dx += Player.accX;
    if(Player.dx > maxVelX)
      Player.dx = maxVelX;
    if(Player.dx < -maxVelX)
      Player.dx = -maxVelX;

    // Atrito
    if(Player.accX == 0)
      Player.dx = 0;
    //if(Math.abs(Player.dx) < 0.01)
    //  Player.dx = 0;

    // VERTICAL
    grav = 0.1; //gravidade
    floatGrav = 0.01; //gravidade quando UP esta pressionado
    floatTime = 42; //por quanto tempo floatGrav dura (frames)
    maxAccY = 0.5; //acc y max
    jmpVel = -7; //velocidade do pulo
    maxVelY = 10; //velocidade max

    if(Control.u){
      if(Player.onGround){
        Player.dy = jmpVel;
        Player.onGround = false;
        auxG = floatTime;
      }else if(auxG > 0){
        auxG--;
      }
    }
    else
      auxG = 0;

    if(!Player.onGround){
      if(auxG == 0)
        Player.accY += grav;
      else{
        Player.accY += floatGrav;
        if(Player.dy >= 0){
          Player.accY = 0;
          Player.dy = 0;
        }
      }

      if(Player.accY > maxAccY)
        Player.accY = maxAccY;
    }

    if(!(Player.y + Player.height/2 + 1 > mapHeight))
      Player.onGround = false;

    Player.dy += Player.accY;
    if(Player.dy > maxVelY)
      Player.dy = maxVelY;

    ////////////////////////////////////////////////////////////////////
    ///COLISION
    ////////////////////////////////////////////////////////////////////

    var bI, bJ;
    bI = Math.floor(Player.y / tamBloco);
    bJ = Math.floor(Player.x / tamBloco);
    var collidedX, collidedY;
    collidedX = collidedY = false;

    var fPlayer = {x: Player.x + Player.dx -Player.width/2,
       y: Player.y + Player.dy -Player.height/2,
       width: Player.width, height: Player.height};
    aux = [false, false, false, false, false, false, false, false];

    //BAIXO
    if(bI < gI -1)
    if(grid[bI+1][bJ] == 1){
      if(rectCollision(fPlayer,
      {x: (bJ) * tamBloco, y: (bI+1) * tamBloco, width: tamBloco, height: tamBloco})){
        Player.dy = 0;
        Player.y = (bI+1) * tamBloco - Player.height/2;
        Player.dy = 0;
        Player.accY = 0;
        Player.onGround = true;
        aux[6] = true;
      }
      else
      Player.onGround = false;
    }

    //CIMA
    if(bI > 0)
    if(grid[bI-1][bJ] == 1){
      if(rectCollision(fPlayer,
      {x: (bJ) * tamBloco, y: (bI-1) * tamBloco, width: tamBloco, height: tamBloco})){
        Player.dy = 0;
        Player.y = (bI) * tamBloco + Player.height/2;
        auxG = 0;
        aux[1] = true;

      }
    }

    fPlayer = {x: Player.x + Player.dx -Player.width/2,
      y: Player.y + Player.dy -Player.height/2,
       width: Player.width, height: Player.height};

    if(Player.dx > 0 && bJ < gJ -1){
      //DIREITA
      if(grid[bI][bJ+1] == 1){
        if(rectCollision(fPlayer,
        {x: (bJ+1) * tamBloco, y: (bI) * tamBloco, width: tamBloco, height: tamBloco})){
          Player.dx = 0;
          Player.x = (bJ+1) * tamBloco - Player.width/2;
          collidedX = true;
          aux[4] = true;
        }
      }

      //DIREITA SUPERIOR
      // if(bI > 0 && !collidedX)
      //   if(grid[bI-1][bJ+1] == 1){
      //     if(rectCollision(fPlayer,
      //     {x: (bJ+1) * tamBloco, y: (bI-1) * tamBloco, width: tamBloco, height: tamBloco})){
      //       Player.dx = 0;
      //       Player.x = (bJ+1) * tamBloco - Player.width/2;
      //       collidedX = true;
      //       aux[2] = true;
      //     }
      //   }

      //DIREITA INFERIOR
      // if(bI < gI -1 && !collidedX)
      //   if(grid[bI+1][bJ+1] == 1){
      //     if(rectCollision(fPlayer,
      //     {x: (bJ+1) * tamBloco, y: (bI+1) * tamBloco, width: tamBloco, height: tamBloco})){
      //       Player.dx = 0;
      //       Player.x = (bJ+1) * tamBloco - Player.width/2;
      //       collidedX = true;
      //       aux[7] = true;
      //     }
      //   }

    }

    else if(Player.dx < 0 && bJ > 0){
      //ESQUERDA
      if(grid[bI][bJ-1] == 1){
        if(rectCollision(fPlayer,
        {x: (bJ-1) * tamBloco, y: (bI) * tamBloco, width: tamBloco, height: tamBloco})){
          Player.dx = 0;
          Player.x = (bJ) * tamBloco + Player.width/2;
          collidedX = true;
          aux[3] = true;
        }
      }

      //ESQUERDA SUPERIOR
      // if(bI > 0 && !collidedX)
      //   if(grid[bI-1][bJ-1] == 1){
      //     if(rectCollision(fPlayer,
      //     {x: (bJ-1) * tamBloco, y: (bI-1) * tamBloco, width: tamBloco, height: tamBloco})){
      //       Player.dx = 0;
      //       Player.x = (bJ) * tamBloco + Player.width/2;
      //       collidedX = true;
      //       aux[0] = true;
      //     }
      //   }

      //ESQUERDA INFERIOR
      // if(bI < gI -1 && !collidedX)
      //   if(grid[bI+1][bJ-1] == 1){
      //     if(rectCollision(fPlayer,
      //     {x: (bJ-1) * tamBloco, y: (bI+1) * tamBloco, width: tamBloco, height: tamBloco})){
      //       Player.dx = 0;
      //       Player.x = (bJ) * tamBloco + Player.width/2;
      //       collidedX = true;
      //       aux[5] = true;
      //     }
      //   }

    }

    Player.x += Player.dx;
    Player.y += Player.dy;

  }

  function boundPlayer(Player){
    if(Player.x + Player.width/2 > mapWidth){
      Player.x = mapWidth - Player.width/2;
      Player.dx = 0;
      Player.accX = 0;
    }
    else if(Player.x - Player.width/2 < 0){
      Player.x = Player.width/2;
      Player.dx = 0;
      Player.accX = 0;
    }

    if(Player.y + Player.height/2 > mapHeight){
      Player.y = mapHeight - Player.height/2;
      Player.dy = 0;
      Player.accY = 0;
      Player.onGround = true;
    }
    else if(Player.y - Player.height/2 < 0){
      Player.y = Player.height/2;
      Player.dy = 0;
    }
  }

// ---------------- DRAW ---------------------------------------------------------------------------------

  function drawPlayer(Player){
    ctx.fillRect(Player.x -Player.width/2 -offset.x, Player.y -Player.height/2 -offset.y, Player.width, Player.height);

    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(Player.x -offset.x +5*Player.accX, Player.y -offset.y, 5, 0, 2*Math.PI, false);
    ctx.fill();
  }

  function drawGrid(){
    ctx.globalAlpha = 1/5;
    ctx.lineWidth = 2;
    for(var i = 0; i < gI+1; ++i){
      ctx.beginPath();
      ctx.moveTo(0 -offset.x, i*tamBloco -offset.y);
      ctx.lineTo(mapWidth -offset.x, i*tamBloco -offset.y);
      ctx.stroke();
    }

    for(var j = 0; j < gJ+1; ++j){
      ctx.beginPath();
      ctx.moveTo(j*tamBloco -offset.x, 0 -offset.y);
      ctx.lineTo(j*tamBloco -offset.x, mapHeight -offset.y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    for(var i = 0; i < gI; i++){
      for(var j = 0; j < gJ; j++){
        if(grid[i][j] == 1){
          ctx.fillRect(j * tamBloco -offset.x, i * tamBloco -offset.y, tamBloco, tamBloco);
        }

      }
    }

  }

// ----------- MANIPULAÇÃO DE TECLAS ----------------------------------------------------------------------

  function keyDown(evt){
    console.log(evt.keyCode);
    switch(evt.keyCode){
      case p1Keys.u:
        p1Control.u = true;
        break;
      case p1Keys.l:
        p1Control.l = true;
        break;
      case p1Keys.d:
        p1Control.d = true;
        break;
      case p1Keys.r:
        p1Control.r = true;
        break;
    }
  }

  function keyUp(evt){
    switch(evt.keyCode){
      case p1Keys.u:
        p1Control.u = false;
        break;
      case p1Keys.l:
        p1Control.l = false;
        break;
      case p1Keys.d:
        p1Control.d = false;
        break;
      case p1Keys.r:
        p1Control.r = false;
        break;
    }
  }

  function mDown(evt){
  }

  function mUp(evt){
  }

  function mMove(evt){
  }

// ---------------- O JOGO -------------------------------------------------------------------------------

  function main(){
    canvas = document.createElement("canvas");

    canvas.width = width;
    canvas.height = height;

    ctx = canvas.getContext("2d");

    window.addEventListener("keydown", keyDown, false);
    window.addEventListener("keyup", keyUp, false);

    ctx.font = "20px Arial";

    document.body.appendChild(canvas);

    run();
  }

  function run(){
    update();
    render();
    window.requestAnimationFrame(run);
  }

  function update(){
    controlPlayer(p1, p1Control);
    boundPlayer(p1);

  	//ZOOM
    //zoom = 1;

  	offset.x = (-(1/zoom)*width/2 + p1.x -p1.width/2);
  	offset.y = (-(1/zoom)*height/2 + p1.y -p1.height/2);

    if(offset.x < 0) offset.x = 0;
    else if(offset.x > mapWidth -width) offset.x = mapWidth -width;

    if(offset.y < 0) offset.y = 0;
    else if(offset.y > mapHeight -height) offset.y = mapHeight -height;



  }

  function render(){
    //Tela Branca
    ctx.fillStyle = "#FFF";
    ctx.fillRect(0, 0, width, height);

    //Salva as configuraçoes atuais do context
    ctx.save();

    //Redimensiona o canvas em X e Y de acordo com esses fatores
    //(se o context nao fosse salvo, o scale iria mudar de forma
    //progressiva (0.5 * 0.5 = 0.25))
    ctx.scale(zoom, zoom);

    //Desenha o player
    ctx.fillStyle = "#F00";
    drawPlayer(p1);

    //Desenha a grid
    ctx.fillStyle = "#000";
    drawGrid();



    ////////////////////////
    //DEBUGGING
    //////////////////////////

    ctx.fillStyle = "#F00";

    //I e J do Player
    var bI, bJ;
    bI = Math.floor(p1.y / tamBloco);
    bJ = Math.floor(p1.x / tamBloco);

    //TILES DE COLISAO
    //[0][1][2]
    //[3][X][4]
    //[5][6][7]

    if(aux[0])
      ctx.fillRect((bJ-1) * tamBloco -offset.x, (bI-1) * tamBloco -offset.y, tamBloco, tamBloco);
    if(aux[1])
      ctx.fillRect((bJ) * tamBloco -offset.x, (bI-1) * tamBloco -offset.y, tamBloco, tamBloco);
    if(aux[2])
      ctx.fillRect((bJ+1) * tamBloco -offset.x, (bI-1) * tamBloco -offset.y, tamBloco, tamBloco);
    if(aux[3])
      ctx.fillRect((bJ-1) * tamBloco -offset.x, (bI) * tamBloco -offset.y, tamBloco, tamBloco);
    if(aux[4])
      ctx.fillRect((bJ+1) * tamBloco -offset.x, (bI) * tamBloco -offset.y, tamBloco, tamBloco);
    if(aux[5])
      ctx.fillRect((bJ-1) * tamBloco -offset.x, (bI+1) * tamBloco -offset.y, tamBloco, tamBloco);
    if(aux[6])
      ctx.fillRect((bJ) * tamBloco -offset.x, (bI+1) * tamBloco -offset.y, tamBloco, tamBloco);
    if(aux[7])
      ctx.fillRect((bJ+1) * tamBloco -offset.x, (bI+1) * tamBloco -offset.y, tamBloco, tamBloco);

    //volta para as configuraçoes salvas
    ctx.restore();


    ctx.fillStyle = "#F00";
    //X E Y DO PLAYER
    ctx.fillText("X: " + p1.x.toFixed(2) + " Y: " + p1.y.toFixed(2), 25, 25);

    //DX E DY DO PLAYER
    ctx.fillText("dX: " + p1.dx.toFixed(2) + " dY: " + p1.dy.toFixed(2), 25, 45);

    //ACCX E ACCY DO PLAYER
    ctx.fillText("accX: " + p1.accX.toFixed(2) + " accY: " + p1.accY.toFixed(2), 25, 65);

    //I E J DO PLAYER
    ctx.fillText("I: " + bI + " J: " + bJ, 25, 85);

    //SE O PLAYER ESTA NO CHAO OU NAO
    ctx.fillText("gnd: " + p1.onGround, 25, 105);

    //OFFSET X E OFFSET Y
    ctx.fillText("offX: " + offset.x.toFixed(2) + " offY: " + offset.y.toFixed(2), 25, 125);

    //COIOTE TIME
    ctx.fillText("Aux: " + auxG, 25, 145);
  }

  main();

</script>
</body>
</html>
